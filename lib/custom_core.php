<?php
/**
 * Custom core functions for speeding WET skin features.
 * @author Ilia Salem, customizing elgg core code
 */


/*
* customized, faster list_river function for main page news feed
*/

function newsfeed_list_river(array $options = array()) {
	global $autofeed;
	$autofeed = true;

	$defaults = array(
		'offset'     => (int) max(get_input('offset', 0), 0),
		'limit'      => (int) max(get_input('limit', max(20, elgg_get_config('default_limit'))), 0),
		'pagination' => true,
		'list_class' => 'elgg-list-river',
		'no_results' => '',
	);

	$options = array_merge($defaults, $options);

	if (!$options["limit"] && !$options["offset"]) {
		// no need for pagination if listing is unlimited
		$options["pagination"] = false;
	}

	// get the river items
	$options['count'] = false;
	$items = elgg_get_river($options);

	// get the river items count only if we need it for pagination
	if ( !is_null( get_input('offset', null) ) ){
		$options['count'] = true;
		$count = elgg_get_river($options);
		$options['count'] = $count;
	}

	$options['items'] = $items;

	return elgg_view('page/components/list', $options);
}


/**
 * Return entities from an SQL query generated by elgg_get_entities.
 *
 * @param string    $sql
 * @param \ElggBatch $batch
 * @return \ElggEntity[]
 *
 * @access private
 * @throws LogicException
 */
function _elgg_wet_fetch_entities_from_sql($sql, \ElggBatch $batch = null) {
	return fetchMessagesFromSql($sql, $batch);
}


/**
	 * Return entities from an SQL query generated by elgg_get_entities.
	 * Customized for fetching messages for the inbox's data table (speeds up loading in cases of 1000s + messages)
	 *
	 * @param string    $sql
	 * @param \ElggBatch $batch
	 * @return \ElggEntity[]
	 *
	 * @access private
	 * @throws \LogicException
	 */
	function fetchMessagesFromSql($sql, \ElggBatch $batch = null) {
		static $plugin_subtype;
		if (null === $plugin_subtype) {
			$plugin_subtype = get_subtype_id('object', 'plugin');
		}
	
		// Keys are types, values are columns that, if present, suggest that the secondary
		// table is already JOINed. Note it's OK if guess incorrectly because entity load()
		// will fetch any missing attributes.
		$types_to_optimize = array(
			'object' => 'title',
			'user' => 'password',
			'group' => 'name',
			'site' => 'url',
		);
	
		$rows = _elgg_services()->db->getData($sql);
	
		// guids to look up in each type
		$lookup_types = array();
		// maps GUIDs to the $rows key
		$guid_to_key = array();
	
		if (isset($rows[0]->type, $rows[0]->subtype)
				&& $rows[0]->type === 'object'
				&& $rows[0]->subtype == $plugin_subtype) {
			// Likely the entire resultset is plugins, which have already been optimized
			// to JOIN the secondary table. In this case we allow retrieving from cache,
			// but abandon the extra queries.
			$types_to_optimize = array();
		}
	
		// First pass: use cache where possible, gather GUIDs that we're optimizing
		foreach ($rows as $i => $row) {
			if (empty($row->guid) || empty($row->type)) {
				throw new \LogicException('Entity row missing guid or type');
			}
			$entity = _elgg_retrieve_cached_entity($row->guid);
			if ($entity) {
				$entity->refresh($row);
				$rows[$i] = $entity;
				continue;
			}
			if (isset($types_to_optimize[$row->type])) {
				// check if row already looks JOINed.
				if (isset($row->{$types_to_optimize[$row->type]})) {
					// Row probably already contains JOINed secondary table. Don't make another query just
					// to pull data that's already there
					continue;
				}
				$lookup_types[$row->type][] = $row->guid;
				$guid_to_key[$row->guid] = $i;
			}
		}
		// Do secondary queries and merge rows
		if ($lookup_types) {
			$dbprefix = _elgg_services()->config->get('dbprefix');
	
			foreach ($lookup_types as $type => $guids) {
				if ( $type = "object" ){
					$set = "(" . implode(',', $guids) . ")";
					$sql = "SELECT guid, title FROM {$dbprefix}{$type}s_entity WHERE guid IN $set";
					$secondary_rows = _elgg_services()->db->getData($sql);
					if ($secondary_rows) {
						foreach ($secondary_rows as $secondary_row) {
							$key = $guid_to_key[$secondary_row->guid];
							// cast to arrays to merge then cast back
							$rows[$key] = (object)array_merge((array)$rows[$key], (array)$secondary_row);
						}
					}
				}
				else {
					$set = "(" . implode(',', $guids) . ")";
					$sql = "SELECT * FROM {$dbprefix}{$type}s_entity WHERE guid IN $set";
					$secondary_rows = _elgg_services()->db->getData($sql);
					if ($secondary_rows) {
						foreach ($secondary_rows as $secondary_row) {
							$key = $guid_to_key[$secondary_row->guid];
							// cast to arrays to merge then cast back
							$rows[$key] = (object)array_merge((array)$rows[$key], (array)$secondary_row);
					}
				}
				}
			}
		}
		// Second pass to finish conversion
		foreach ($rows as $i => $row) {
			if ($row instanceof \ElggEntity) {
				continue;
			} else {
				try {
					$rows[$i] = entity_row_to_elggstar($row);
				} catch (IncompleteEntityException $e) {
					// don't let incomplete entities throw fatal errors
					unset($rows[$i]);
	
					// report incompletes to the batch process that spawned this query
					if ($batch) {
						$batch->reportIncompleteEntity($row);
					}
				}
			}
		}
		return $rows;
	}

?>